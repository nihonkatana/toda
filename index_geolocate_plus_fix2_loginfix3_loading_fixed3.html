<!doctype html>
<html lang="ja">

<head>
  <meta name="robots" content="noindex, nofollow">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ²ç¤ºå ´ãƒŠãƒ“é“ - æˆ¸ç”°å¸‚ç‰ˆ</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="./styles.css">
  <link rel="stylesheet" href="./tweaks.css">

  <style>
    /* ç¾åœ¨åœ°ãƒœã‚¿ãƒ³ï¼ˆLeafletï¼‰ */
    .leaflet-control.locate-btn a{
      display:flex;
      align-items:center;
      justify-content:center;
      width:38px;height:38px;
      border-radius:10px;
      background:rgba(20, 120, 255, .95);
      color:#fff;
      text-decoration:none;
      font-size:18px;
      box-shadow:0 6px 18px rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.25);
    }
    .leaflet-control.locate-btn a:active{ transform: translateY(1px); }
    .distBadge{
      display:inline-block;
      margin-left:8px;
      padding:3px 8px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.22);
      background:rgba(255,255,255,.08);
      opacity:.9;
    }
  
    .recoTitle{
      font-size:13px;
      font-weight:700;
      margin:6px 0 10px 0;
      opacity:.92;
    }
    .recommend .item{
      border-left:4px solid rgba(255,255,255,.25);
    }
    .leaflet-control.locate-btn a,
    .leaflet-control.follow-btn a{
      display:flex;
      align-items:center;
      justify-content:center;
      width:36px;
      height:36px;
      background:#fff;
      border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,.18);
      text-decoration:none;
      font-size:18px;
    }
    .leaflet-control.follow-btn a{
      font-size:12px;
      font-weight:700;
      width:56px;
    }
    .leaflet-control.bounds-btn a{
      display:flex;
      align-items:center;
      justify-content:center;
      width:38px;
      height:38px;
      background:#fff;
      border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,.18);
      text-decoration:none;
      font-size:18px;
    }


  
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

</style>

</head>

<body>
  <div class="topbar">
    <div class="row space" id="precinctDetailHeader">
      <div class="left">
        <img class="nav-logo" src="./image/nav_logo_master_1024.png" alt="æ²ç¤ºå ´ãƒŠãƒ“" />
        <div class="title">æ²ç¤ºå ´ãƒŠãƒ“é“ - æˆ¸ç”°å¸‚ç‰ˆ</p></div>
      </div>
      <div class="row" style="gap:8px">
        <span id="rolePill" class="pill">æœªãƒ­ã‚°ã‚¤ãƒ³</span>
        <button class="btn small ghost" onclick="app.openSettings()">âš™ï¸</button>
      </div>
    </div>

    <div class="row space" style="margin-top:10px">
      <div class="kpi">
        <span class="pill" id="userPill">ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼š-</span>
        <span class="pill" id="modePill">ç§»å‹•ï¼šè»Š</span>
        <span class="pill" id="geoPill">ç¾åœ¨åœ°ï¼šæœªå–å¾—</span>
      </div>
      <button class="btn small" onclick="app.reload()">æ›´æ–°</button>
    </div>
  </div>

  <div class="toast" id="toast">
    <div class="card">
      <div id="toastText"></div>
    </div>
  </div>


  <!-- Loading Overlay -->
  <div id="loadingOverlay" style="
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35); z-index:99999;
  ">
    <div style="
      background:#fff; padding:14px 16px; border-radius:12px; max-width:86vw;
      box-shadow:0 8px 30px rgba(0,0,0,.25); font-size:16px; line-height:1.6;
    ">
      <div style="display:flex; align-items:center; gap:10px;">
        <div id="loadingSpinner" style="
          width:18px; height:18px; border-radius:999px;
          border:3px solid rgba(0,0,0,.15); border-top-color:rgba(0,0,0,.55);
          animation:spin 1s linear infinite;
        "></div>
        <div id="loadingMsg" style="color:#111; font-weight:700;">å‡¦ç†ä¸­â€¦</div>
      </div>
      <div style="margin-top:10px; text-align:center; font-size:13px; opacity:.85; color:#333;">
        ãã®ã¾ã¾ãŠå¾…ã¡ãã ã•ã„
      </div>
    </div>
  </div>

  <div class="wrap">

    <!-- AUTH / REGISTER -->
    <div id="authView" class="card" style="display:none">
      <div class="h2">ã¯ã˜ã‚ã«</div>
      <div class="muted" style="font-size:15px;line-height:1.55">
        æ²ç¤ºå ´ãƒŠãƒ“ã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼æ¨å¥¨ã§ã™ã€‚Androidã¯Chrome, iPhoneã¯Safali ã«ãƒªãƒ³ã‚¯ã‚’è²¼ã‚Šä»˜ã‘ã¦é–‹ã„ã¦ãã ã•ã„ã€‚<br>
          <div class="muted" style="font-size:15px;line-height:1.55">
            LINEå†…ã®ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹ã„ãŸå ´åˆã¯ã€ä¸‹è¨˜ã®æ“ä½œã‚’è¡Œã£ã¦ãã ã•ã„ã€‚
          </div>
          <div class="muted" style="font-size:15px;line-height:1.55">
            â‘  ç”»é¢å³ä¸‹ã® <b>ã€Œâ€¦ï¼ˆç‚¹ã€…ï¼‰ã€</b> ã‚’æŠ¼ã™<br>
            â‘¡ <b>ã€Œï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ï¼‰ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ãã€</b> ã‚’æŠ¼ã™
            </div>
          <div style="margin:24px 0;text-align:center">
            <img src="./image/open_browser.png" alt="å³ä¸‹ã®ç‚¹ã€…ã‚’æŠ¼ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã" style="max-width:100%;border-radius:12px">
          </div>

      </div>
<!--
      <div style="margin-top:16px"></div>
      <div class="h2">åˆå›ç™»éŒ²</div>
      <div class="muted" style="font-size:15px;line-height:1.55">
        ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã¨è­˜åˆ¥åã‚’ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚<br>
        è­˜åˆ¥åã¯ã€LINEè¡¨ç¤ºåãŒã‚ã‚‹æ–¹ã¯ãã®è¡¨ç¤ºåã€LINEãŒãªã„æ–¹ã¯ãƒ¡ãƒ³ãƒãƒ¼ãŒè­˜åˆ¥ã§ãã‚‹åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚<br>
        åˆå›ç™»éŒ²å¾Œã€è²¬ä»»è€…ãŒæ‰¿èªã™ã‚‹ã¨åˆ©ç”¨é–‹å§‹ã§ãã¾ã™ã€‚ç™»éŒ²ã—ãŸã“ã¨ã‚’è²¬ä»»è€…ã«ã”é€£çµ¡ãã ã•ã„ã€‚<br>
      </div>
-->
      <div style="margin-top:32px"></div>
      <div class="h2">ãƒ­ã‚°ã‚¤ãƒ³</div>
      <div class="muted" style="font-size:15px;line-height:1.55">
        æ‹…å½“è¡¨ã«è¨˜è¼‰ã®ãƒ­ã‚°ã‚¤ãƒ³IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚<br>
        ä¸€åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ãŸå¾Œã€ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ãªã„é™ã‚Šæ¯å›ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
      </div>

      <div style="margin-top:14px">
        <div class="h3">ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆå¿…é ˆï¼‰</div>
        <input id="inNick" class="field" placeholder="ä¾‹ï¼šã˜ã‚‡ãƒ¼ã‹ãƒ¼" />
      </div>
      <div style="margin-top:12px">
        <div class="h3">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆå¿…é ˆï¼‰</div>
        <input id="inIdName" class="field" placeholder="ä¾‹ï¼šJoker" />
      </div>

      <div class="sep"></div>
      <button class="btn primary block" onclick="app.register()">ãƒ­ã‚°ã‚¤ãƒ³</button>

      <div class="tiny" style="margin-top:12px">
        ãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„å ´åˆã¯ã€LINEã‚°ãƒ«ãƒ¼ãƒ—ã®Moto3ã«é€£çµ¡ã—ã¦ãã ã•ã„ã€‚
      </div>
    </div>

    <!-- PENDING (waiting approval) -->
    <div id="pendingView" class="card" style="display:none">
      <div class="h2">æ‰¿èªå¾…ã¡</div>
      <div class="muted" style="font-size:13px;line-height:1.6">
        ã„ã¾ã¯ <b>æ‰¿èªå¾…ã¡</b> ã§ã™ã€‚è²¬ä»»è€…ãŒæ‰¿èªã™ã‚‹ã¨åˆ©ç”¨ã§ãã¾ã™ã€‚<br>
        ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã€Œæ›´æ–°ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚
      </div>
      <div class="sep"></div>
      <button class="btn primary block" onclick="app.reload()">æ›´æ–°ã™ã‚‹</button>
      <div class="tiny" style="margin-top:10px">
        â€»æ‰¿èªãŒå¿…è¦ãªå ´åˆã¯ã€è²¬ä»»è€…ã¸ã€Œãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã€ã¨ã€Œè­˜åˆ¥åã€ã‚’é€£çµ¡ã—ã¦ãã ã•ã„ã€‚
      </div>
    </div>



<!-- FIELD -->
    <div id="fieldView">
      <div id="fieldTopAnchor"></div>
      <div class="card">
        <div class="row space">
          <div id="precHeader">
            <div class="h2">æ‹…å½“æŠ•ç¥¨åŒº</div>
            <div class="muted" style="font-size:15px">å‰²å½“ã•ã‚ŒãŸæŠ•ç¥¨åŒºã®ã¿è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
              ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ç§»å‹•æ‰‹æ®µã¯ã€Œè»Šã€ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            </div>
          </div>
          <button class="btn small" onclick="app.openTravelModePicker()">ç§»å‹•æ‰‹æ®µ</button>
        </div>

        <div class="sep"></div>
        <div class="h3" id="fieldOverviewTitle" style="margin-top:10px">æ‹…å½“æŠ•ç¥¨åŒº å…¨ä½“ãƒãƒƒãƒ—</div>
        <div class="muted" style="font-size:12px;line-height:1.5">
          é’æ ãŒã‚ãªãŸã®æ‹…å½“æŠ•ç¥¨åŒºã§ã™ã€‚ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ãã®æŠ•ç¥¨åŒºã‚’é–‹ãã¾ã™ã€‚
        </div>
        <div id="fieldOverviewMap"
          style="height: 42vh; min-height: 280px; border-radius: 16px; overflow:hidden; border:1px solid rgba(255,255,255,.12); margin-top:10px;">
        </div>
        
        <div class="sep"></div>

        <div id="precinctList" class="list"></div>
      </div>

      <!-- Precinct Detail -->
      <div id="precinctDetail" class="card" style="display:none">
        <div class="row space">
          <div id="precinctDetailAnchor">
            <div class="h2" id="precTitle">æŠ•ç¥¨åŒº</div>
            <div class="muted" id="precSub" style="font-size:15px"></div>
            <div id="precNote" class="muted small" style="margin-top:6px;"></div>
          </div>
          <button class="btn small ghost" onclick="app.closePrecinct()">å…¨ä½“ãƒãƒƒãƒ—ã¸æˆ»ã‚‹</button>
        </div>

        <!-- Map (Leaflet) only here -->
        <div id="precinctMapAnchor"></div>
        <div id="mapWrap" style="margin-top:12px">
          <div id="map"></div>
          <div class="mapHint">
            åœ°å›³ã®ãƒ”ãƒ³ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã€ãã®åœ°ç‚¹ã®æ“ä½œãŒã§ãã¾ã™ï¼ˆå˜ç‚¹ãƒŠãƒ“ï¼æ¸ˆï¼æœªã«æˆ»ã™ï¼ãƒ¡ãƒ¢ï¼‰ã€‚
          </div>
        </div>

        <div class="sep"></div>

        <div class="grid2">
          <button class="btn primary block" onclick="app.startNavRecommended()">æ¬¡ã®1åœ°ç‚¹ãƒŠãƒ“ï¼ˆæœªã®å…ˆé ­ï¼‰</button>
          <button class="btn block" onclick="app.pickNextPoint()">æ¬¡ç‚¹ã‚’é¸ã¶</button>
        </div>

        <div class="tiny" style="margin-top:10px">
          ãƒŠãƒ“ãƒãƒƒãƒ—ã®é †ç•ªã¯ã€ã€Œæ¬¡ç‚¹ã‚’é¸ã¶ã€ã§æŒ‡å®šã—ãªã„é™ã‚Šã€æœªè¨ªå•ã®æ²ç¤ºå ´ã®è¨­ç½®ç•ªå·é †ã¨ãªã‚Šã¾ã™ã€‚<br>
          ã€Œå˜ç‚¹ãƒŠãƒ“ã€ã¯ç¾åœ¨åœ°ã‹ã‚‰ãã®æ²ç¤ºå ´ã¾ã§ã®ãƒ«ãƒ¼ãƒˆåœ°å›³ãŒé–‹ãã¾ã™ã€‚<br><br>
          ãƒã‚¹ã‚¿ãƒ¼ã‚’è²¼ã‚Šçµ‚ãˆãŸæ²ç¤ºå ´ã¯ã€ã€Œæ¸ˆã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚ã—ã°ã‚‰ãã™ã‚‹ã¨ï¼ˆæœªï¼‰ãƒãƒƒã‚¸ãŒï¼ˆæ¸ˆï¼‰ã«å¤‰ã‚ã‚Šã¾ã™ã€‚<br>
        </div>

        <div class="sep"></div>
<div id="pointList" class="list"></div>
      </div>
    </div>

    <!-- SUMMARY -->
    <div id="sumView" style="display:none">
      <div class="card">
        <div class="row space">
          <div>
            <div class="h2">é›†è¨ˆï¼ˆå…¨ä½“ï¼‰</div>
            <div class="tiny"><p>ãƒ‡ãƒ¼ã‚¿é›†è¨ˆã¨è¡¨ç¤ºã¾ã§æ•°ç§’ãŠå¾…ã¡ãã ã•ã„ã€‚</p>
              æŠ•ç¥¨åŒºã¨çŠ¶æ…‹ï¼ˆæœª/æ¸ˆï¼‰ã§çµã‚Šè¾¼ã¿ï¼ˆANDï¼‰ã§ãã¾ã™ã€‚ãƒ¡ãƒ¢ã‚‚è¡¨ç¤ºã—ã¾ã™ã€‚</div>
          </div>
          <button class="btn small" onclick="app.loadSummary()">å†èª­è¾¼</button>
        </div>

        <div class="sep"></div>

        <div class="h3">çµã‚Šè¾¼ã¿</div>
        <div class="grid2">
          <div>
            <div class="tiny" style="margin-bottom:6px">æŠ•ç¥¨åŒº</div>
            <select id="sumArea" class="field" onchange="app.renderSummary()">
              <option value="">ï¼ˆå…¨æŠ•ç¥¨åŒºï¼‰</option>
            </select>
          </div>
          <div id="sumUserWrap" style="display:none">
            <div class="tiny" style="margin-bottom:6px">ãƒ¦ãƒ¼ã‚¶ï¼ˆæ‹…å½“è€…ï¼‰</div>
            <select id="sumUser" class="field" onchange="app.renderSummary()">
              <option value="">ï¼ˆå…¨ãƒ¦ãƒ¼ã‚¶ï¼‰</option>
            </select>
          </div>
          <div>
            <div class="tiny" style="margin-bottom:6px">çŠ¶æ…‹ï¼ˆANDï¼‰</div>
            <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:2px">
              <label class="pill" style="display:flex;gap:8px;align-items:center">
                <input type="checkbox" id="sumTodo" checked />
                æœª
              </label>
              <label class="pill" style="display:flex;gap:8px;align-items:center">
                <input type="checkbox" id="sumDone" checked />
                æ¸ˆ
              </label>
              <label class="pill" style="display:flex;gap:8px;align-items:center">
                <input type="checkbox" id="sumMemo" />
                ãƒ¡ãƒ¢ä»˜
              </label>
            </div>
          </div>
        </div>

        <div class="sep"></div>

        <div class="row space">
          <div class="kpi">
            <span class="pill" id="sumKpiTotal">ç·æ•°ï¼š-</span>
            <span class="pill" id="sumKpiTodo">æœªï¼š-</span>
            <span class="pill" id="sumKpiDone">æ¸ˆï¼š-</span>
          </div>
        </div>

        <div class="sep"></div>

        <div id="sumList" class="list"></div>

        <div class="tiny" style="margin-top:12px">
          â€»é›†è¨ˆã¯GASå´ã« <span class="mono">action:"summary_get"</span> ãŒå¿…è¦ã§ã™ï¼ˆæœªå®Ÿè£…ã®å ´åˆã¯ã€Œæœªå¯¾å¿œã€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ï¼‰ã€‚
        </div>
      </div>
    </div>

    <!-- ALLOCATOR -->
    <div id="allocView" style="display:none">
      <div class="card">
        <div class="row space">
          <div class="h2" style="margin:0">è²¬ä»»è€… <span id="pendingBadge" class="badge badgePending" style="display:none;margin-left:6px">0</span></div>
          <div class="right" style="flex-wrap:wrap">
            <button class="btn small primary" id="btnAllocSubAssign" onclick="app.switchAllocSub('assign')">å‰²å½“</button>
            <button class="btn small ghost" id="btnAllocSubAllow" onclick="app.switchAllocSub('allow')">ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆ</button>
          </div>
        </div>
        <div class="muted" style="margin-top:10px">
          <p>ãƒ‡ãƒ¼ã‚¿é›†è¨ˆã¨è¡¨ç¤ºã¾ã§æ•°ç§’ãŠå¾…ã¡ãã ã•ã„ã€‚</p>
          ã€Œå‰²å½“ã€ã¨ã€Œãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã€ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚
        </div>
      </div>

      <div class="card" id="allocAssignSection">
        <div class="h2">å‰²å½“</div>
        <div class="tiny">
          è¤‡æ•°äººåŒæ™‚æ“ä½œã‚’æƒ³å®šã—ã€æŠ•ç¥¨åŒºã”ã¨ã« version ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ç«¶åˆã—ãŸå ´åˆã¯ã€Œç«¶åˆã€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ï¼ˆæ›´æ–°ã—ã¦ã‚„ã‚Šç›´ã—ï¼‰ã€‚
        </div>
        <div class="sep"></div>

        <div class="h3">æ‹…å½“è€…æ¤œç´¢ï¼ˆusersï¼‰</div>
        <input id="inUserSearch" class="field" placeholder="è¡¨ç¤ºåã§æ¤œç´¢ï¼ˆä¾‹ï¼šãŸãªã‹ï¼‰" oninput="app.renderUserCandidates()" />
        <div id="userCandidates" class="list" style="margin-top:12px"></div>

        <div class="sep"></div>

        <div class="h3">å…¨ä½“ãƒãƒƒãƒ—ï¼ˆæŠ•ç¥¨åŒºã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠï¼‰</div>
        <div class="muted" style="font-size:12px;line-height:1.5">
          é’=æœªå‰²å½“ / ç·‘=å‰²å½“æ¸ˆã€‚ãƒãƒªã‚´ãƒ³ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨æŠ•ç¥¨åŒºã®é¸æŠï¼ˆãƒã‚§ãƒƒã‚¯ï¼‰ã«é€£å‹•ã—ã¾ã™ã€‚
        </div>
        <div id="allocMap"
          style="height: 46vh; min-height: 320px; border-radius: 16px; overflow:hidden; border:1px solid rgba(255,255,255,.12); margin-top:10px;">
        </div>

        <div class="h3">æŠ•ç¥¨åŒºä¸€è¦§</div>
        <div class="tiny" style="margin-bottom:10px">è¤‡æ•°é¸æŠã—ã¦ä¸€æ‹¬å‰²å½“ã§ãã¾ã™ã€‚</div>

        <div class="grid2">
          <button class="btn primary block" onclick="app.bulkAssign()">é¸æŠã‚’å‰²å½“</button>
          <button class="btn block" style="background:rgba(255,92,92,.18);border:1px solid rgba(255,92,92,.35)"
            onclick="app.bulkUnassign()">é¸æŠã‚’è§£é™¤</button>
        </div>

        <div style="margin-top:12px">
          <input id="inAssignNote" class="field" placeholder="ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼šåˆå‰æ‹…å½“/å¼•ãç¶™ãç­‰ï¼‰" />
        </div>

        <div class="sep"></div>
        <div id="assignList" class="list"></div>
      </div>

      <div class="card" id="allocPendingSection" style="margin-top:12px">
        <div class="h2">æ‰¿èªå¾…ã¡ãƒ¦ãƒ¼ã‚¶ãƒ¼</div>
        <div class="muted" style="font-size:12px;line-height:1.5">
          æ–°è¦ç™»éŒ²ã¯ã€Œpendingã€ã§ä»®ç™»éŒ²ã•ã‚Œã¾ã™ã€‚ã“ã“ã§æ‰¿èªã™ã‚‹ã¨ active ã«ãªã‚Šåˆ©ç”¨é–‹å§‹ã§ãã¾ã™ã€‚
        </div>
        <div class="sep"></div>
        <div id="pendingList" class="list"></div>
        <div class="tiny" style="margin-top:10px">
          â€»å´ä¸‹ã¯ status=rejected ã«ã—ã¾ã™ï¼ˆå†ç™»éŒ²ã¯åŒä¸€ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ï¼‹è­˜åˆ¥åã ã¨åŒã˜ user_id ãŒè¿”ã‚Šã¾ã™ï¼‰ã€‚
        </div>
      </div>
    </div>

  </div>

  <!-- Tabs -->
  <div class="tabs" id="tabs" style="display:none">
    <div class="tab active" id="tabField" onclick="app.switchTab('field')">ç¾å ´</div>
    <div class="tab" id="tabSum" onclick="app.switchTab('sum')">é›†è¨ˆ</div>
    <div class="tab" id="tabAlloc" onclick="app.switchTab('alloc')">
      è²¬ä»»è€… <span id="pendingBadge" class="badge badgePending" style="display:none;margin-left:6px;">æ‰¿èªå¾…ã¡ 0</span>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" onclick="if(event.target===this) app.closeSettings()"
    style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.40); z-index:1001;">

    <div style="background:var(--card); border:1px solid rgba(255,255,255,.12); color:var(--text);
                margin:12vh auto; padding:16px; width:min(92vw,460px); border-radius:18px;">
      <div class="row space">
        <div class="h2" style="margin:0;">è¨­å®š</div>
        <button class="btn small ghost" onclick="app.closeSettings()">âœ•</button>
      </div>

      <div class="sep"></div>
      <div id="currentUserBox" class="muted"></div>

      <div class="sep"></div>
      <div class="tiny" style="margin-top:12px">
        â€»ç«¯æœ«ã‚’ä»–ã®äººã¨å…±ç”¨ã™ã‚‹å ´åˆã®ã¿ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¦ãã ã•ã„ã€‚é€šå¸¸ã¯ä¸è¦ã§ã™ã€‚
      </div>
      <button class="btn block" style="background:rgba(255,92,92,.18);border:1px solid rgba(255,92,92,.35)"
        onclick="app.logout()">
        ã“ã®ç«¯æœ«ã‹ã‚‰ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
      </button>

      <!--ç¾å ´ãƒãƒ‹ãƒ¥ã‚¢ãƒ« -->
      <div class="tiny" style="margin-top:12px">
        â€»å›°ã£ãŸã¨ãã¯ã“ã¡ã‚‰
      </div>
      <button class="btn ghost block" onclick="window.open('manual_field.html','_blank')">
        ğŸ“˜ ç¾å ´å‘ã‘ é“
      </button>
      <div id="allocatorManualSlot"></div>

    </div>
  </div>

  <script>
    /** =========================
     *  CONFIG
     * ========================= */
    const GAS_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbxS75U51Qsm-ZfrFx6O9s3ofbyjO7EyN4t3lzmnN9lnic9vgksiAsViWGWsYgwkRr1WBQ/exec";

    /** =========================
     *  STATE
     * ========================= */
    const store = {
      user_id: localStorage.getItem("user_id") || "",
      display_name: localStorage.getItem("display_name") || "",
      role: localStorage.getItem("role") || "",
  user_status: localStorage.getItem("user_status") || "",
      travel_mode: localStorage.getItem("travel_mode") || "driving", // driving|walking
      assigned_areas: [],
      points: [],
      state: {}, // point_id -> {status,memo}
      current_area: "",
  current_tab: localStorage.getItem("current_tab") || "field",

      // allocator caches
      allUsers: [],
      assignments: [],
      selectedAssignee: null,
      selectedAreas: new Set(),

      allocPointsAll: [],
      allocMap: null,
      allocMapLayers: { hulls: null, markers: null },
      allocAreaPolys: new Map(),

      pendingUsers: [],

      // map
      map: null,
      mapMarkers: [],
      mapArea: "",

      // field map
      fieldOverviewMap: null,
      fieldOverviewLayers: { hulls: null },
      fieldOverviewAssignedBounds: null,
      areaPointsBounds: null,

      // geolocation
      geo: { ok: false, lat: null, lng: null, accuracy: null, ts: null },
      geoWatchId: null,
      geoLayers: { marker: null, circle: null },
      geoControlsBound: new Set(),
      geoFollow: false,
      geoFollowControls: new Set(),


      // summary cache
      summary: { ok: false, points: [], state: {} },
      area_notes: {},
      summary_area_to_user: {}, // area_id -> assignee_display_nameï¼ˆé›†è¨ˆã®ãƒ¦ãƒ¼ã‚¶çµã‚Šè¾¼ã¿ç”¨ï¼‰

      // é€ä¿¡ä¸­ã‚¬ãƒ¼ãƒ‰ï¼ˆé€£æ‰“é˜²æ­¢ï¼‰
      inFlight: new Set(),
    };

    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

    const ui = {
      toast: (msg) => {
        const t = document.getElementById("toast");
        const tx = document.getElementById("toastText");
        tx.innerHTML = msg;
        t.classList.add("show");
        setTimeout(() => t.classList.remove("show"), 2400);
      },

      setTop: () => {
        document.getElementById("userPill").textContent = store.display_name ? `ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼š${store.display_name}` : "ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼š-";
        const modeLabel = store.travel_mode === "walking" ? "å¾’æ­©" : "è»Š";
        document.getElementById("modePill").textContent = `ç§»å‹•ï¼š${modeLabel}`;
        document.getElementById("rolePill").textContent = store.role ? `role: ${store.role}` : "æœªãƒ­ã‚°ã‚¤ãƒ³";
      }
    };

    
    /** =========================
     *  LOADING (wait message)
     * ========================= */
    let __loadingCount = 0;

    function actionToLoadingMsg_(payload) {
      const a = payload && payload.action ? String(payload.action) : "";
      // Friendly messages for heavy tabs/actions
      if (a.startsWith("admin") || a.includes("summary") || a.includes("alloc")) return "å‡¦ç†ä¸­â€¦ï¼ˆå°‘ã—æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ï¼‰";
      if (a === "register") return "ãƒ­ã‚°ã‚¤ãƒ³ä¸­â€¦";
      if (a.includes("save") || a.includes("update") || a.includes("set")) return "ä¿å­˜ä¸­â€¦";
      return "é€šä¿¡ä¸­â€¦";
    }

    function setLoading_(isOn, msg) {
      const ov = document.getElementById("loadingOverlay");
      const el = document.getElementById("loadingMsg");
      if (!ov || !el) return;

      if (isOn) {
        __loadingCount += 1;
        if (msg) el.textContent = msg;
        ov.style.display = "flex";
      } else {
        __loadingCount = Math.max(0, __loadingCount - 1);
        if (__loadingCount === 0) ov.style.display = "none";
      }
    }

/** =========================
     *  HTTP
     * ========================= */
    
async function postAction(payload) {
  if (!GAS_WEBAPP_URL || GAS_WEBAPP_URL.includes("YOUR_GAS_WEBAPP_URL_HERE")) {
    ui.toast("GAS_WEBAPP_URL ã‚’è¨­å®šã—ã¦ãã ã•ã„");
    throw new Error("Missing GAS_WEBAPP_URL");
  }

  // show wait message (especially for è²¬ä»»è€…ã‚¿ãƒ– / é›†è¨ˆ)
  setLoading_(true, actionToLoadingMsg_(payload));
  try {
    const res = await fetch(GAS_WEBAPP_URL, {
      method: "POST",
      headers: { "Content-Type": "text/plain;charset=utf-8" }, // preflightå›é¿
      body: JSON.stringify(payload),
    });
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); }
    catch { throw new Error("Bad JSON response: " + text.slice(0, 200)); }
    return data;
  } finally {
    setLoading_(false);
  }
}

    /** =========================
     *  SAFE HTML
     * ========================= */
    function escapeHtml_(s) {
      s = String(s ?? "");
      return s.replace(/[&<>"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[c]));
    }

    function cssEscape_(s) {
      s = String(s ?? "");
      if (window.CSS && CSS.escape) return CSS.escape(s);
      return s.replace(/["\\#.;?+*~':!^$[\]()=>|/@]/g, "\\$&");
    }

    function setBusyForPoint_(point_id, busy, clickedBtn) {
      const pid = String(point_id || "");
      if (!pid) return;

      const sel = `[data-pid="${cssEscape_(pid)}"]`;
      const btns = document.querySelectorAll(sel);

      btns.forEach(b => {
        if (!(b instanceof HTMLElement)) return;
        b.disabled = !!busy;
        b.setAttribute("aria-busy", busy ? "true" : "false");
        b.classList.toggle("is-busy", !!busy);
      });

      if (clickedBtn && clickedBtn instanceof HTMLElement) {
        if (busy) {
          clickedBtn.dataset.prevText = clickedBtn.textContent || "";
          clickedBtn.textContent = "ä¿å­˜ä¸­â€¦";
        } else {
          const prev = clickedBtn.dataset.prevText;
          if (prev != null) clickedBtn.textContent = prev;
          delete clickedBtn.dataset.prevText;
        }
      }
    }

    function computeAreaKpi_(areaId) {
      const pts = store.points.filter(p => p.area_id === areaId);
      const total = pts.length;
      const todo = pts.filter(p => (store.state[p.point_id]?.status || "todo") === "todo").length;
      const done = pts.filter(p => (store.state[p.point_id]?.status || "todo") === "done").length;
      return { total, todo, done };
    }

    function updatePrecinctHeader_(areaId) {
      if (!areaId) return;
      const { total, todo, done } = computeAreaKpi_(areaId);
      const num = String(areaId).replace(/^P0*/, "");
      const sub = document.getElementById("precSub");
      const title = document.getElementById("precTitle");
      if (title) title.textContent = `æŠ•ç¥¨åŒºï¼š${num}`;
      if (sub) sub.textContent =
        `åœ°ç‚¹ï¼š${total} / æœªï¼š${todo} / æ¸ˆï¼š${done} / ç§»å‹•ï¼š${store.travel_mode === "walking" ? "å¾’æ­©" : "è»Š"}`;

      const noteEl = document.getElementById("precNote");
      if (noteEl) {
        const note = (store.area_notes && store.area_notes[areaId]) ? String(store.area_notes[areaId]) : "";
        noteEl.textContent = note ? `å¼•ç¶™ããƒ¡ãƒ¢ï¼š${note}` : "";
        noteEl.style.display = note ? "block" : "none";
      }
    }

    function scrollToAnchor_(elOrId) {
      const el = (typeof elOrId === "string") ? document.getElementById(elOrId) : elOrId;
      if (!el) return;

      // ç”»é¢ä¸Šéƒ¨ã®å›ºå®šãƒ˜ãƒƒãƒ€ãƒ¼åˆ†ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
      const topbar = document.querySelector(".topbar");
      const offset = (topbar ? topbar.offsetHeight : 0) + 10;

      // displayåˆ‡æ›¿ç›´å¾Œã¯ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒæœªç¢ºå®šãªã“ã¨ãŒã‚ã‚‹ã®ã§2æ‹å¾…ã¤
      requestAnimationFrame(() => {
        setTimeout(() => {
          const rect = el.getBoundingClientRect();
          const y = window.pageYOffset + rect.top - offset;
          window.scrollTo({ top: Math.max(0, y), behavior: "smooth" });
        }, 50);
      });
    }

    
    /** =========================
     *  GEO / DISTANCE
     * ========================= */
    function haversineMeters_(lat1, lng1, lat2, lng2) {
      const R = 6371000; // meters
      const toRad = (d) => (d * Math.PI) / 180;
      const p1 = toRad(Number(lat1)), p2 = toRad(Number(lat2));
      const dLat = toRad(Number(lat2) - Number(lat1));
      const dLng = toRad(Number(lng2) - Number(lng1));
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(p1) * Math.cos(p2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(a)));
    }

    function formatMeters_(m) {
      if (!isFinite(m)) return "";
      if (m < 1000) return `${Math.round(m)}m`;
      return `${(m / 1000).toFixed(1)}km`;
    }

/** =========================
     *  MAP URLS
     * ========================= */
    function encodeLoc(lat, lng) {
      return `${Number(lat).toFixed(7)},${Number(lng).toFixed(7)}`;
    }

    function buildSingleNavUrl(lat, lng, travelMode) {
      const t = (travelMode === "walking") ? "w" : "d";
      if (isIOS()) {
        return `https://maps.apple.com/?daddr=${encodeURIComponent(encodeLoc(lat, lng))}&dirflg=${t}`;
      }
      return `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(encodeLoc(lat, lng))}&travelmode=${encodeURIComponent(travelMode || "driving")}`;
    }

    function openNavInNewTab(url) {
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    /** =========================
     *  LEAFLET ICON
     * ========================= */
    function markerIcon_(status) {
      const cls = (status === "done") ? "done" : "todo";
      return L.divIcon({
        className: "",
        html: `<div class="leaf-dot-wrap"><div class="leaf-dot ${cls}"></div></div>`,
        iconSize: [16, 16],
        iconAnchor: [8, 8],
        popupAnchor: [0, -8],
      });
    }

    /** =========================
     *  BADGE
     * ========================= */
    function statusBadge(status) {
      if (status === "done") return `<span class="badge bDone">æ¸ˆ</span>`;
      return `<span class="badge bTodo">æœª</span>`;
    }

    /** =========================
     *  APP
     * ========================= */
    const app = {
      async init() {
        ui.setTop();
        app.updateGeoStatusUI_();
        // start watching as early as possible so "è¿‘ã„é †" and current location work
        app.ensureGeoWatch_();
        setTimeout(() => {
          document.getElementById("sumTodo")?.addEventListener("change", () => app.renderSummary());
          document.getElementById("sumDone")?.addEventListener("change", () => app.renderSummary());
          document.getElementById("sumMemo")?.addEventListener("change", () => app.renderSummary());
          document.getElementById("sumUser")?.addEventListener("change", () => app.renderSummary());
        }, 0);

        if (!store.user_id) {
          app.showAuth();
          return;
        }
        await app.bootstrap();
      },

      showAuth() {
        document.getElementById("authView").style.display = "block";
    document.getElementById("pendingView").style.display = "none";
        document.getElementById("fieldView").style.display = "none";
        document.getElementById("sumView").style.display = "none";
        document.getElementById("allocView").style.display = "none";
        document.getElementById("tabs").style.display = "none";
      }
,

  showPending(){
    document.getElementById("authView").style.display = "none";
    document.getElementById("pendingView").style.display = "none";
    document.getElementById("fieldView").style.display = "none";
    document.getElementById("allocView").style.display = "none";
    document.getElementById("tabs").style.display = "none";
    document.getElementById("pendingView").style.display = "block";
  }
,

  async register() {
        const nickname = document.getElementById("inNick").value.trim();
        const id_name = document.getElementById("inIdName").value.trim();
        if (!nickname || !id_name) { ui.toast("å¿…é ˆé …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }

        ui.toast("ãƒ­ã‚°ã‚¤ãƒ³ä¸­â€¦");
        const data = await postAction({ action: "register", nickname, id_name });
        if (!data.ok) {
          if (data.error === "NOT_ALLOWED") ui.toast("ãƒ­ã‚°ã‚¤ãƒ³ã§ãã¾ã›ã‚“ï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆæœªç™»éŒ²ï¼‰");
          else ui.toast("å¤±æ•—ï¼š" + (data.error || "ä¸æ˜"));
          return;
        }

        store.user_id = data.user.user_id;
        store.display_name = data.user.display_name;
        store.role = data.user.role;
    store.user_status = data.user.status || "active";

        localStorage.setItem("user_id", store.user_id);
        localStorage.setItem("display_name", store.display_name);
        localStorage.setItem("role", store.role);
    localStorage.setItem("user_status", store.user_status);
    localStorage.setItem("user_status", store.user_status);
        localStorage.setItem("travel_mode", store.travel_mode);

        ui.setTop();
        await app.bootstrap();
      },

      async bootstrap() {
        ui.toast("èª­ã¿è¾¼ã¿ä¸­â€¦");
        const data = await postAction({ action: "bootstrap", user_id: store.user_id });
        if (!data.ok) {
          ui.toast("èªè¨¼ã‚¨ãƒ©ãƒ¼ã€‚ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™");
          app.logout();
          return;
        }

        store.display_name = data.user.display_name || store.display_name;
        store.role = data.user.role || store.role;
    store.user_status = data.user.status || store.user_status || "active";
        localStorage.setItem("display_name", store.display_name);
        localStorage.setItem("role", store.role);
    localStorage.setItem("user_status", store.user_status);

        store.assigned_areas = data.assigned_areas || [];
        store.points = data.points || [];
        store.state = data.state || {};
        store.area_notes = data.area_notes || {};

        ui.setTop();

        document.getElementById("tabs").style.display = "flex";
        const canAlloc = (store.role === "allocator" || store.role === "planner");
        document.getElementById("tabAlloc").style.display = canAlloc ? "block" : "none";

        // default tabï¼ˆå›ºå®šã—ãªã„ï¼‰
        // - planner/allocator ã¯ã€Œè²¬ä»»è€…ã‚¿ãƒ–ã‚’ç¶­æŒã€ã—ã‚„ã™ã„ã‚ˆã†ã«ã€å‰å›ã‚¿ãƒ–ã‚’å„ªå…ˆ
        // - field ã¯å¸¸ã«ç¾å ´
        const lastTab = localStorage.getItem("last_tab") || ""; // "field" or "alloc"

        let firstTab = "field";
        if (canAlloc && lastTab === "alloc") firstTab = "alloc";

        app.switchTab(firstTab);
        app.renderPrecinctList();

        app.renderFieldOverviewMap_();
      },

      async reload() {
        if (!store.user_id) { app.showAuth(); return; }
        await app.bootstrap();
        if (document.getElementById("tabSum").classList.contains("active")) {
          await app.loadSummary();
        }
        if ((store.role === "allocator" || store.role === "planner") && document.getElementById("tabAlloc").classList.contains("active")) {
          await app.loadAllocatorData();
        }
      },

      logout() {
        localStorage.removeItem("user_id");
        localStorage.removeItem("display_name");
        localStorage.removeItem("role");
        store.user_id = "";
        store.display_name = "";
        store.role = "";
        store.assigned_areas = [];
        store.points = [];
        store.state = {};
        store.current_area = "";
        store.summary = { ok: false, points: [], state: {} };
        ui.setTop();
        app.closeSettings();
        app.showAuth();
      },

      closeSettings() {
        const modal = document.getElementById("settingsModal");
        if (modal) modal.style.display = "none";
      },

      switchTab(which) {
        store.current_tab = which;
        localStorage.setItem("last_tab", which); // â† ã“ã‚Œã ã‘æ®‹ã™

        document.getElementById("tabField").classList.toggle("active", which === "field");
        document.getElementById("tabSum").classList.toggle("active", which === "sum");
        document.getElementById("tabAlloc").classList.toggle("active", which === "alloc");

        document.getElementById("fieldView").style.display = which === "field" ? "block" : "none";
        document.getElementById("sumView").style.display = which === "sum" ? "block" : "none";
        document.getElementById("allocView").style.display = which === "alloc" ? "block" : "none";
        document.getElementById("authView").style.display = "none";
        document.getElementById("pendingView").style.display = "none";

        if (which === "sum") {
          app.loadSummary().catch(err => ui.toast("é›†è¨ˆå–å¾—ã«å¤±æ•—ï¼š" + err.message));
        }

        if (which === "alloc") {
          if (!(store.role === "allocator" || store.role === "planner")) {
            ui.toast("æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“");
            app.switchTab("field");
            return;
          }
          app.switchAllocSub("assign");
          app.loadAllocatorData().catch(err => ui.toast("å‰²å½“ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ï¼š" + err.message));
        }
      },

      switchAllocSub(which) {
        const isAssign = (which === "assign");
        const secAssign = document.getElementById("allocAssignSection");
        const secAllow = document.getElementById("allocAllowSection");
        const btnAssign = document.getElementById("btnAllocSubAssign");
        const btnAllow = document.getElementById("btnAllocSubAllow");

        if (secAssign) secAssign.style.display = isAssign ? "block" : "none";
        if (secAllow) secAllow.style.display = isAssign ? "none" : "block";

        if (btnAssign && btnAllow) {
          btnAssign.classList.toggle("primary", isAssign);
          btnAssign.classList.toggle("ghost", !isAssign);
          btnAllow.classList.toggle("primary", !isAssign);
          btnAllow.classList.toggle("ghost", isAssign);
        }

        window.scrollTo({ top: 0, behavior: "smooth" });
      },

      openSettings() {
        const box = document.getElementById("currentUserBox");
        if (box) {
          box.textContent = store.user_id ? `ãƒ­ã‚°ã‚¤ãƒ³ä¸­ï¼š${store.display_name}ï¼ˆ${store.role}ï¼‰` : "æœªãƒ­ã‚°ã‚¤ãƒ³";
        }
       
        //ç®¡ç†è€…ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ï¼š
        const slot = document.getElementById("allocatorManualSlot");
        if (slot) {
          const canAlloc = (store.role === "allocator" || store.role === "planner");
          slot.innerHTML = "";
          if (canAlloc) {
            const btn = document.createElement("button");
            btn.className = "btn ghost block";
            btn.textContent = "ğŸ“™ æ²ç¤ºå ´ã®å‰²å½“èª¬æ˜ã¨å‰²å½“ãƒãƒƒãƒ—";
            btn.onclick = () => window.open("brief.html", "_blank");
            slot.appendChild(btn);
          }
        }

        document.getElementById("settingsModal").style.display = "block";
      },

      openTravelModePicker() {
        const current = store.travel_mode;
        const msg = `ç§»å‹•æ‰‹æ®µã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆD=è»Š / W=å¾’æ­©ï¼‰\n\n` +
          `${current === "driving" ? "â—" : "â—‹"} D è»Š\n` +
          `${current === "walking" ? "â—" : "â—‹"} W å¾’æ­©`;
        const chosen = prompt(msg, current === "walking" ? "W" : "D");
        if (!chosen) return;
        const v = chosen.trim().toUpperCase();
        if (!["D", "W"].includes(v)) { ui.toast("å…¥åŠ›ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“"); return; }
        store.travel_mode = (v === "W") ? "walking" : "driving";
        localStorage.setItem("travel_mode", store.travel_mode);
        ui.setTop();
        ui.toast("ç§»å‹•æ‰‹æ®µã‚’å¤‰æ›´ã—ã¾ã—ãŸ");
      },

      
      /** -------- Geolocation (ç¾åœ¨åœ°) -------- */
      
      updateGeoStatusUI_() {
        const pill = document.getElementById("geoPill");
        if (!pill) return;

        // default
        if (!navigator.geolocation) { pill.textContent = "ç¾åœ¨åœ°ï¼šéå¯¾å¿œ"; return; }

        if (store.geo && store.geo.ok && isFinite(store.geo.lat) && isFinite(store.geo.lng)) {
          const acc = isFinite(store.geo.accuracy) ? `Â±${Math.round(store.geo.accuracy)}m` : "";
          pill.textContent = `ç¾åœ¨åœ°ï¼šOK ${acc}`.trim();
          return;
        }

        if (store.geoWatchId != null) {
          pill.textContent = "ç¾åœ¨åœ°ï¼šå–å¾—ä¸­â€¦";
        } else {
          pill.textContent = "ç¾åœ¨åœ°ï¼šæœªå–å¾—";
        }
      },

      setGeoFollow_(on) {
        store.geoFollow = !!on;
        app.updateGeoFollowControls_();
        app.updateGeoStatusUI_();
        if (store.geoFollow) {
          app.panMapsToGeo_();
        }
      },

      updateGeoFollowControls_() {
        // update all follow control buttons
        const els = document.querySelectorAll(".leaflet-control.follow-btn a[data-follow]");
        for (const el of els) {
          el.textContent = store.geoFollow ? "è¿½å¾“ON" : "è¿½å¾“OFF";
          el.setAttribute("aria-pressed", store.geoFollow ? "true" : "false");
        }
      },

      panMapsToGeo_() {
        if (!store.geo || !store.geo.ok) return;
        const latlng = [store.geo.lat, store.geo.lng];

        if (store.map && store.map.panTo) {
          try { store.map.panTo(latlng, { animate: true }); } catch { }
        }
        if (store.fieldOverviewMap && store.fieldOverviewMap.panTo) {
          try { store.fieldOverviewMap.panTo(latlng, { animate: true }); } catch { }
        }
      },

      fitMapToContent_(mapObj) {
        if (!mapObj) return;

        // æ‹…å½“æŠ•ç¥¨åŒº å…¨ä½“ãƒãƒƒãƒ—ï¼šæ‹…å½“ç¯„å›²ã¸æˆ»ã™
        if (store.fieldOverviewMap && mapObj === store.fieldOverviewMap) {
          if (store.fieldOverviewAssignedBounds) {
            try { mapObj.fitBounds(store.fieldOverviewAssignedBounds, { padding: [16, 16] }); } catch (e) { }
            ui.toast("æ‹…å½“æŠ•ç¥¨åŒºã®ç¯„å›²ã¸æˆ»ã—ã¾ã—ãŸ");
            return;
          }
        }

        // æŠ•ç¥¨åŒºè©³ç´°ãƒãƒƒãƒ—ï¼šãã®æŠ•ç¥¨åŒºã®æ²ç¤ºå ´ç¯„å›²ã¸æˆ»ã™
        if (store.map && mapObj === store.map) {
          if (store.areaPointsBounds) {
            try { mapObj.fitBounds(store.areaPointsBounds, { padding: [20, 20] }); } catch (e) { }
            ui.toast("æŠ•ç¥¨åŒºã®ç¯„å›²ã¸æˆ»ã—ã¾ã—ãŸ");
            return;
          }
        }

        ui.toast("ç¯„å›²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      },

      ensureGeoWatch_() {
        if (!navigator.geolocation) return;

        if (store.geoWatchId != null) return; // already watching

        const opts = { enableHighAccuracy: true, maximumAge: 8000, timeout: 12000 };

        app.updateGeoStatusUI_();

        store.geoStartTs = Date.now();
        // if first fix never comes, show a helpful hint (some in-app browsers block GPS)
        store.geoStallTimer = setTimeout(() => {
          if (!store.geo || !store.geo.ok) {
            const pill = document.getElementById("geoPill");
            if (pill) pill.textContent = "ç¾åœ¨åœ°ï¼šå–å¾—ã§ããšï¼ˆğŸ“ã§å†å–å¾—ï¼‰";
            if (!store.geoStallNotified) {
              store.geoStallNotified = true;
              ui.toast("ç¾åœ¨åœ°ãŒå–ã‚Œãªã„å ´åˆã¯Safari/Chromeã§é–‹ãã¨å®‰å®šã—ã¾ã™");
            }
          }
        }, 15000);

        store.geoWatchId = navigator.geolocation.watchPosition(
          // show "getting" immediately

          (pos) => {
            const c = pos.coords || {};
            const lat = Number(c.latitude), lng = Number(c.longitude), acc = Number(c.accuracy);
            if (!isFinite(lat) || !isFinite(lng)) return;

            store.geo = { ok: true, lat, lng, accuracy: isFinite(acc) ? acc : null, ts: Date.now() };

            if (store.geoStallTimer) { clearTimeout(store.geoStallTimer); store.geoStallTimer = null; }
            store.geoStallNotified = false;

            app.updateGeoLayers_();
            app.updateGeoStatusUI_();
            if (store.geoFollow) app.panMapsToGeo_();

            if (store.current_area) {
              app.renderPointList_(store.current_area);
              updatePrecinctHeader_(store.current_area);
            }
          },
          (err) => {
            const code = err && err.code;
            const pill = document.getElementById("geoPill");
            if (pill) {
              if (code === 1) pill.textContent = "ç¾åœ¨åœ°ï¼šæœªè¨±å¯";
              else pill.textContent = "ç¾åœ¨åœ°ï¼šå–å¾—å¤±æ•—";
            }
            if (!store.geo || !store.geo.ok) {
              if (code === 1) ui.toast("ç¾åœ¨åœ°ï¼šè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆè¿‘ã„é †ã¯ä½¿ãˆã¾ã›ã‚“ï¼‰");
              else ui.toast("ç¾åœ¨åœ°ï¼šå–å¾—ã§ãã¾ã›ã‚“ï¼ˆè¿‘ã„é †ã¯ä½¿ãˆã¾ã›ã‚“ï¼‰");
            }
          },
          opts
        );
      },

      requestGeoOnce_(why) {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation || !navigator.geolocation.getCurrentPosition) {
            reject(new Error("no_geolocation"));
            return;
          }
          const opts = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              const c = pos.coords || {};
              const lat = Number(c.latitude), lng = Number(c.longitude), acc = Number(c.accuracy);
              if (!isFinite(lat) || !isFinite(lng)) { reject(new Error("bad_coords")); return; }
              store.geo = { ok: true, lat, lng, accuracy: isFinite(acc) ? acc : null, ts: Date.now() };

              if (store.geoStallTimer) { clearTimeout(store.geoStallTimer); store.geoStallTimer = null; }
              store.geoStallNotified = false;

              app.updateGeoLayers_();
              app.updateGeoStatusUI_();
              resolve(store.geo);
            },
            (err) => {
              reject(err || new Error("geo_error"));
            },
            opts
          );
        });
      },

      addLocateControlToMap_(mapObj) {
        if (!mapObj) return;
        const key = String(mapObj._leaflet_id || "");
        if (store.geoControlsBound.has(key)) return;

        const ctrl = L.control({ position: "bottomright" });
        ctrl.onAdd = () => {
          const div = L.DomUtil.create("div", "leaflet-control locate-btn");
          const a = L.DomUtil.create("a", "", div);
          a.href = "#";
          a.title = "ç¾åœ¨åœ°ã¸";
          a.setAttribute("aria-label", "ç¾åœ¨åœ°ã¸");
          a.innerHTML = "ğŸ“";
          L.DomEvent.on(a, "click", (e) => {
            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
            app.panToCurrentLocation_(mapObj);
          });
          return div;
        };
        ctrl.addTo(mapObj);

        // follow toggle control
        const fctrl = L.control({ position: "bottomright" });
        fctrl.onAdd = () => {
          const div = L.DomUtil.create("div", "leaflet-control follow-btn");
          const a = L.DomUtil.create("a", "", div);
          a.href = "#";
          a.title = "ç¾åœ¨åœ°ã‚’è¿½å¾“ï¼ˆON/OFFï¼‰";
          a.setAttribute("aria-label", "ç¾åœ¨åœ°ã‚’è¿½å¾“ï¼ˆON/OFFï¼‰");
          a.setAttribute("data-follow", "1");
          a.textContent = store.geoFollow ? "è¿½å¾“ON" : "è¿½å¾“OFF";
          L.DomEvent.on(a, "click", (e) => {
            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
            app.setGeoFollow_(!store.geoFollow);
          });
          return div;
        };
        fctrl.addTo(mapObj);

        // fit-to-content control (æ‹…å½“ç¯„å›²/æŠ•ç¥¨åŒºç¯„å›²ã¸æˆ»ã™)
        const bctrl = L.control({ position: "bottomright" });
        bctrl.onAdd = () => {
          const div = L.DomUtil.create("div", "leaflet-control bounds-btn");
          const a = L.DomUtil.create("a", "", div);
          a.href = "#";
          a.title = "ç¯„å›²ã¸ï¼ˆæ‹…å½“/æŠ•ç¥¨åŒºï¼‰";
          a.setAttribute("aria-label", "ç¯„å›²ã¸ï¼ˆæ‹…å½“/æŠ•ç¥¨åŒºï¼‰");
          a.innerHTML = "ğŸ—º";
          L.DomEvent.on(a, "click", (e) => {
            L.DomEvent.preventDefault(e);
            L.DomEvent.stopPropagation(e);
            app.fitMapToContent_(mapObj);
          });
          return div;
        };
        bctrl.addTo(mapObj);

        // if user drags the map, stop following automatically
        const followKey = "followBound:" + key;
        if (!store.geoFollowControls.has(followKey)) {
          mapObj.on("dragstart", () => {
            if (store.geoFollow) app.setGeoFollow_(false);
          });
          store.geoFollowControls.add(followKey);
        }

        store.geoControlsBound.add(key);
        app.updateGeoFollowControls_();
      },

      panToCurrentLocation_(mapObj)
      {
        app.ensureGeoWatch_();
        if (!store.geo || !store.geo.ok) {
          ui.toast("ç¾åœ¨åœ°ã‚’å–å¾—ä¸­â€¦ï¼ˆè¨±å¯ãŒå¿…è¦ã§ã™ï¼‰");
          // iOS/ä¸€éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ watchPosition ãŒå‹•ã‹ãªã„ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§ä¸€åº¦ã ã‘å†å–å¾—
          app.requestGeoOnce_("pan").then(() => {
            if (store.geo && store.geo.ok) app.panToCurrentLocation_(mapObj);
          }).catch(() => {});
          return;
        }

        const lat = store.geo.lat, lng = store.geo.lng;
        const acc = store.geo.accuracy;

        const targetMap = mapObj || store.map || store.fieldOverviewMap;
        if (targetMap) {
          // ä½ç½®ã‚’è¡¨ç¤ºã™ã‚‹ãŒã€ã‚ºãƒ¼ãƒ ã¯å‹æ‰‹ã«å¤‰ãˆãªã„ï¼ˆæŠ•ç¥¨åŒº/æ²ç¤ºå ´ãŒæ¶ˆãˆã‚‹æ··ä¹±ã‚’é˜²ãï¼‰
          try { targetMap.panTo([lat, lng], { animate: true }); } catch (e) { }

          // ã€Œæˆ»ã‚‹ã€ç”¨ã«å†…å®¹ç¯„å›²ã¸æˆ»ã™ãƒœã‚¿ãƒ³ã‚’ç”¨æ„ã—ã¦ã„ã‚‹ï¼ˆæ‹…å½“ç¯„å›²/æŠ•ç¥¨åŒºç¯„å›²ï¼‰
          // â€»è‡ªå‹•ã§æˆ»ã•ãªã„ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¾åœ¨åœ°å‘¨è¾ºã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
        }
        ui.toast("ç¾åœ¨åœ°ã‚’è¡¨ç¤ºã—ã¾ã—ãŸï¼ˆå¿…è¦ãªã‚‰ã€Œç¯„å›²ã¸ã€ã§æˆ»ã‚Œã¾ã™ï¼‰");
      },

      updateGeoLayers_() {
        const lat = store.geo?.lat, lng = store.geo?.lng;
        if (!store.geo?.ok || !isFinite(lat) || !isFinite(lng)) return;

        const maps = [store.map, store.fieldOverviewMap].filter(Boolean);

        for (const mp of maps) {
          try {
            app.addLocateControlToMap_(mp);

            const mapKey = String(mp._leaflet_id || "");
            if (!store.geoLayersByMap) store.geoLayersByMap = new Map();
            const entry = store.geoLayersByMap.get(mapKey) || { marker: null, circle: null };

            // é’ä¸¸ï¼ˆç¾åœ¨åœ°ï¼‰
            if (!entry.marker) {
              entry.marker = L.circleMarker([lat, lng], {
                radius: 7,
                weight: 2,
                color: "#1976ff",
                fillColor: "#1976ff",
                fillOpacity: 0.85
              });
            } else {
              entry.marker.setLatLng([lat, lng]);
            }
            entry.marker.addTo(mp);

            // ç²¾åº¦å††
            const acc = Number(store.geo.accuracy);
            if (isFinite(acc) && acc > 0) {
              if (!entry.circle) {
                entry.circle = L.circle([lat, lng], {
                  radius: acc,
                  weight: 1,
                  color: "#1976ff",
                  fillColor: "#1976ff",
                  fillOpacity: 0.12
                });
              } else {
                entry.circle.setLatLng([lat, lng]);
                entry.circle.setRadius(acc);
              }
              entry.circle.addTo(mp);
            }

            store.geoLayersByMap.set(mapKey, entry);
          } catch (e) { }
        }
      },

/** -------- Field: precinct list/detail -------- */
      renderPrecinctList() {
        const el = document.getElementById("precinctList");
        el.innerHTML = "";

        

    // pending user: show message first
    if (store.user_status === "pending") {
      el.innerHTML = `
        <div class="item">
          <div class="itemTitle">æ‰¿èªå¾…ã¡</div>
          <div class="itemSub">è²¬ä»»è€…ãŒæ‰¿èªã™ã‚‹ã¾ã§ã€ç¾å ´æ©Ÿèƒ½ã¯ä½¿ãˆã¾ã›ã‚“ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚</div>
        </div>`;
      return;
    }
if (!store.assigned_areas || store.assigned_areas.length === 0) {
          el.innerHTML = `
            <div class="item">
              <div style="font-weight:1000;font-size:16px">å‰²å½“ãªã—</div>
              <div class="tiny">è²¬ä»»è€…ãŒæŠ•ç¥¨åŒºã‚’å‰²ã‚Šå½“ã¦ã‚‹ã¾ã§ã€ã“ã“ã«ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚</div>
            </div>`;
          return;
        }

        const pointsByArea = new Map();
        for (const p of store.points) {
          if (!pointsByArea.has(p.area_id)) pointsByArea.set(p.area_id, []);
          pointsByArea.get(p.area_id).push(p);
        }

        const sortedAreas = store.assigned_areas.slice().sort();
        for (const area of sortedAreas) {
          const pts = (pointsByArea.get(area) || []).slice().sort((a, b) => a.order_reco - b.order_reco || a.point_id.localeCompare(b.point_id));
          const total = pts.length;
          const todo = pts.filter(x => (store.state[x.point_id]?.status || "todo") === "todo").length;
          const done = pts.filter(x => (store.state[x.point_id]?.status || "todo") === "done").length;

          const num = area.replace(/^P0*/, "");
          const item = document.createElement("div");
          item.className = "item";
          item.innerHTML = `
            <div class="itemTop">
              <div>
                <div style="font-weight:1000;font-size:18px;line-height:1.25">æŠ•ç¥¨åŒºï¼š${escapeHtml_(num)}</div>
                <div class="tiny">åœ°ç‚¹ï¼š${total} / æœªï¼š${todo} / æ¸ˆï¼š${done}</div>
              </div>
              <div class="row" style="gap:8px">
                <button class="btn small primary">é–‹ã</button>
              </div>
            </div>
          `;
          item.querySelector("button").onclick = () => app.openPrecinct(area, { keepScroll: false });
          el.appendChild(item);
        }
      },

      openPrecinct(areaId, opts = {}) {
        app.ensureGeoWatch_();
        store.current_area = areaId;
        document.getElementById("precinctDetail").style.display = "block";

        // map
        document.getElementById("mapWrap").style.display = "block";
        app.renderMapForArea_(areaId);

        // list
        app.renderPointList_(areaId);

        updatePrecinctHeader_(areaId);
        // ã€ŒæŠ•ç¥¨åŒºï¼šN / åœ°ç‚¹ï¼š...ã€ã®ãƒ†ã‚­ã‚¹ãƒˆãŒè¦‹ãˆã‚‹ä½ç½®ã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆä»•æ§˜ï¼‰
        scrollToAnchor_("precinctDetailAnchor");

        // Leafletã¯è¡¨ç¤ºç›´å¾Œã«ã‚µã‚¤ã‚ºè¨ˆç®—ãŒã‚ºãƒ¬ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ä¿é™º
        setTimeout(() => { try { store.map?.invalidateSize(); } catch (e) { } }, 80);
      },

      closePrecinct() {
        store.current_area = "";
        document.getElementById("precinctDetail").style.display = "none";
        app.renderPrecinctList();

        // âœ… ç¾å ´ã‚¿ãƒ–ã®æœ€ä¸Šéƒ¨ï¼ˆæ‹…å½“æŠ•ç¥¨åŒºâ€¦ã®è¦‹å‡ºã—ï¼‰ã¸æˆ»ã™
        scrollToAnchor_("fieldTopAnchor");
      },

      renderPointList_(areaId) {
        const list = document.getElementById("pointList");
        list.innerHTML = "";

        const hasGeo = !!(store.geo && store.geo.ok && isFinite(store.geo.lat) && isFinite(store.geo.lng));

        // âœ… areaå†…ã®å…¨åœ°ç‚¹ã‚’ã€(æœªâ†’æ¸ˆ) å„ªå…ˆã—ã¤ã¤ã€Œè¿‘ã„é †ã€ï¼‹è·é›¢è¡¨ç¤ºã«ã™ã‚‹
        const pts = (store.points || [])
          .filter(p => String(p.area_id) === String(areaId))
          .map(p => {
            let dist = null;
            if (hasGeo && isFinite(Number(p.lat)) && isFinite(Number(p.lng))) {
              dist = haversineMeters_(store.geo.lat, store.geo.lng, Number(p.lat), Number(p.lng));
            }
            return { ...p, __dist: dist };
          })
          .sort((a, b) => {
            const sa = (store.state[a.point_id]?.status || "todo");
            const sb = (store.state[b.point_id]?.status || "todo");
            if (sa !== sb) return sa === "todo" ? -1 : 1;

            const da = a.__dist, db = b.__dist;
            const ha = isFinite(da), hb = isFinite(db);
            if (ha && hb) return da - db;
            if (ha && !hb) return -1;
            if (!ha && hb) return 1;

            return (a.order_reco - b.order_reco) || String(a.point_id).localeCompare(String(b.point_id));
          });

        for (const p of pts) {
          const st = store.state[p.point_id]?.status || "todo";
          const memo = store.state[p.point_id]?.memo || "";

          const item = document.createElement("div");
          item.className = "item";
          item.innerHTML = `
            <div class="pointMeta">
              #${p.order_reco} / ${escapeHtml_(p.point_id)} ${statusBadge(st)}
              ${isFinite(p.__dist) ? `<span class="distBadge">ç¾åœ¨åœ°ã‹ã‚‰ ${escapeHtml_(formatMeters_(p.__dist))}</span>` : ``}
            </div>
            <div class="pointName">${escapeHtml_((p.name || "").trim())}</div>
            <div class="pointAddr">${escapeHtml_((p.address || "").trim())}</div>
            ${memo ? `<div class="pointMemo">ğŸ“ ${escapeHtml_(memo)}</div>` : ``}

            <div class="actions">
              <button class="btn small" data-act="nav"  data-pid="${escapeHtml_(p.point_id)}">å˜ç‚¹ãƒŠãƒ“</button>
              <button class="btn small done" data-act="done" data-pid="${escapeHtml_(p.point_id)}">æ¸ˆ</button>
              <button class="btn small todo" data-act="todo" data-pid="${escapeHtml_(p.point_id)}">æœªã«æˆ»ã™</button>
              <button class="btn small memo" data-act="memo" data-pid="${escapeHtml_(p.point_id)}">ãƒ¡ãƒ¢</button>
            </div>
          `;

          item.querySelector('[data-act="nav"]').onclick = () => app.startSingleNav(p.point_id);
          item.querySelector('[data-act="done"]').onclick = (e) => app.handlePointAction("done", p.point_id, e.currentTarget);
          item.querySelector('[data-act="todo"]').onclick = (e) => app.handlePointAction("todo", p.point_id, e.currentTarget);
          item.querySelector('[data-act="memo"]').onclick = (e) => app.handlePointAction("memo", p.point_id, e.currentTarget);

          list.appendChild(item);
        }
      },

      getTodoPointsInArea_(areaId) {
        const hasGeo = !!(store.geo && store.geo.ok && isFinite(store.geo.lat) && isFinite(store.geo.lng));

        const pts = store.points
          .filter(p => p.area_id === areaId)
          .map(p => {
            let dist = null;
            if (hasGeo && isFinite(Number(p.lat)) && isFinite(Number(p.lng))) {
              dist = haversineMeters_(store.geo.lat, store.geo.lng, Number(p.lat), Number(p.lng));
            }
            return { ...p, __dist: dist };
          })
          .slice()
          .sort((a, b) => {
            const da = a.__dist, db = b.__dist;
            const ha = isFinite(da), hb = isFinite(db);
            if (ha && hb) return da - db;
            if (ha && !hb) return -1;
            if (!ha && hb) return 1;
            return (a.order_reco - b.order_reco) || a.point_id.localeCompare(b.point_id);
          });

        return pts.filter(p => (store.state[p.point_id]?.status || "todo") === "todo");
      },

      async startNavRecommended() {
        const area = store.current_area;
        if (!area) { ui.toast("æŠ•ç¥¨åŒºã‚’é–‹ã„ã¦ãã ã•ã„"); return; }
        const todoPts = app.getTodoPointsInArea_(area);
        if (todoPts.length === 0) { ui.toast("æœªè¨ªå•ãŒã‚ã‚Šã¾ã›ã‚“"); return; }
        app.startSingleNav(todoPts[0].point_id);
      },

      async pickNextPoint() {
        const area = store.current_area;
        if (!area) { ui.toast("æŠ•ç¥¨åŒºã‚’é–‹ã„ã¦ãã ã•ã„"); return; }
        const todoPts = app.getTodoPointsInArea_(area);
        if (todoPts.length === 0) { ui.toast("æœªè¨ªå•ãŒã‚ã‚Šã¾ã›ã‚“"); return; }

        const options = todoPts.slice(0, 30)
          .map(p => {
            const d = isFinite(p.__dist) ? ` (${formatMeters_(p.__dist)})` : "";
            return `#${p.order_reco} ${p.point_id}${d} ${(p.name || "").slice(0, 18)}`;
          })
          .join("\n");
        const input = prompt(
          "æ¬¡ã«è¡Œãåœ°ç‚¹ã® point_id ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆæœªè¨ªå•ã‹ã‚‰ï¼‰\n\nå€™è£œï¼ˆå…ˆé ­30ï¼‰:\n" + options,
          todoPts[0].point_id
        );
        if (!input) return;

        const pid = input.trim();
        const hit = todoPts.find(p => p.point_id === pid);
        if (!hit) { ui.toast("æœªè¨ªå•ã® point_id ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
        app.startSingleNav(pid);
      },

      async startSingleNav(point_id) {
        const p = store.points.find(x => x.point_id === point_id);
        if (!p) { ui.toast("åœ°ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return; }

        const url = buildSingleNavUrl(p.lat, p.lng, store.travel_mode);

        // iPhoneå¯¾ç­–ï¼šå…ˆã«é–‹ã
        openNavInNewTab(url);

        // ãƒ­ã‚°ã¯å¾Œã§
        postAction({
          action: "nav_start",
          actor_user_id: store.user_id,
          area_id: p.area_id,
          included_point_ids: [p.point_id],
          maps_url: url,
          client_time: new Date().toISOString()
        }).catch(() => { });
      },

      async handlePointAction(action, point_id, clickedBtn) {
        const p = store.points.find(x => x.point_id === point_id);
        if (!p) { ui.toast("åœ°ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return; }

        const pid = String(point_id || "");
        const inFlightKey = pid;

        if (store.inFlight.has(inFlightKey)) {
          ui.toast("ä¿å­˜ä¸­ã§ã™â€¦");
          return;
        }

        const prev = {
          status: store.state[pid]?.status || "todo",
          memo: store.state[pid]?.memo || ""
        };

        let nextStatus = action;
        let nextMemo = prev.memo;

        if (action === "memo") {
          const m = prompt("ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„", prev.memo);
          if (m === null) return;
          nextMemo = m.trim();
          nextStatus = prev.status;
        }

        store.inFlight.add(inFlightKey);
        setBusyForPoint_(pid, true, clickedBtn);

        store.state[pid] = { status: nextStatus, memo: nextMemo };
        app.renderPointList_(p.area_id);
        app.updateMapMarker_(pid);
        updatePrecinctHeader_(p.area_id);
        ui.toast("ä¿å­˜ä¸­â€¦");

        try {
          const data = await postAction({
            action: "state_update",
            actor_user_id: store.user_id,
            updates: [{
              point_id: pid,
              status: nextStatus,
              memo: nextMemo,
              client_time: new Date().toISOString()
            }]
          });

          if (!data.ok) throw new Error(data.error || "æ›´æ–°å¤±æ•—");
          const r = (data.results || []).find(x => x.point_id === pid);
          if (r && !r.ok) throw new Error(r.error || "æ›´æ–°æ‹’å¦");

          ui.toast("ä¿å­˜ã—ã¾ã—ãŸ");
        } catch (err) {
          store.state[pid] = { status: prev.status, memo: prev.memo };
          app.renderPointList_(p.area_id);
          app.updateMapMarker_(pid);
          updatePrecinctHeader_(p.area_id);
          ui.toast("ä¿å­˜å¤±æ•—ï¼š" + (err?.message || "ä¸æ˜"));
        } finally {
          store.inFlight.delete(inFlightKey);
          setBusyForPoint_(pid, false, clickedBtn);
        }
      },

      /** -------- Allocator: overview map (all precinct hulls) -------- */
      areaLabel_(areaId) {
        const m = String(areaId || "").match(/(\d+)/);
        const n = m ? String(parseInt(m[1], 10)) : String(areaId || "");
        return `æŠ•ç¥¨åŒºï¼š${n}`;
      },

      groupPointsByArea_(points) {
        const map = new Map();
        for (const p of points || []) {
          const a = String(p.area_id || "");
          if (!a) continue;
          if (!map.has(a)) map.set(a, []);
          map.get(a).push(p);
        }
        return map;
      },

      convexHull_(pts) {
        const arr = pts
          .filter(p => isFinite(p.lat) && isFinite(p.lng))
          .map(p => ({ x: p.lng, y: p.lat, lat: p.lat, lng: p.lng }))
          .sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);

        if (arr.length <= 1) return arr.map(p => ({ lat: p.lat, lng: p.lng }));

        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        const lower = [];
        for (const p of arr) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
          lower.push(p);
        }
        const upper = [];
        for (let i = arr.length - 1; i >= 0; i--) {
          const p = arr[i];
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
          upper.push(p);
        }
        upper.pop(); lower.pop();
        return lower.concat(upper).map(p => ({ lat: p.lat, lng: p.lng }));
      },

      allocStyleForArea_(areaId) {
        const a = (store.assignments || []).find(x => String(x.area_id) === String(areaId));
        const assigned = !!(a && a.assignee_user_id);
        const selected = store.selectedAreas.has(String(areaId));

        const stroke = assigned ? "#00D26A" : "#2F7CFF";
        return {
          color: stroke,
          weight: selected ? 4 : 2,
          fillColor: stroke,
          fillOpacity: assigned ? (selected ? 0.26 : 0.18) : (selected ? 0.24 : 0.16),
        };
      },

      renderAllocOverviewMap_() {
        const canAlloc = (store.role === "allocator" || store.role === "planner");
        if (!canAlloc) return;

        const container = document.getElementById("allocMap");
        if (!container) return;

        if (!store.allocMap) {
          store.allocMap = L.map("allocMap", { zoomControl: true });
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "&copy; OpenStreetMap contributors"
          }).addTo(store.allocMap);

          store.allocMapLayers.hulls = L.layerGroup().addTo(store.allocMap);
          store.allocMapLayers.markers = L.layerGroup().addTo(store.allocMap);
        }

        try { store.allocMapLayers.hulls.clearLayers(); } catch (e) { }
        try { store.allocMapLayers.markers.clearLayers(); } catch (e) { }
        store.allocAreaPolys = new Map();

        const byArea = app.groupPointsByArea_(store.allocPointsAll || []);
        const bounds = [];

        for (const [areaId, pts] of byArea.entries()) {
          const latlngs = pts.map(p => ({ lat: Number(p.lat), lng: Number(p.lng) }))
            .filter(x => isFinite(x.lat) && isFinite(x.lng));
          if (latlngs.length === 0) continue;

          const label = app.areaLabel_(areaId);

          if (latlngs.length === 1) {
            const mk = L.circleMarker([latlngs[0].lat, latlngs[0].lng], {
              radius: 7,
              color: app.allocStyleForArea_(areaId).color,
              weight: 2,
              fillOpacity: 0.6
          }).bindTooltip(label, {
            permanent: true,
            direction: "top",
            className: "hullLabel",
            opacity: 0.95
          });
  
            mk.on("click", () => app.toggleAllocAreaSelection_(areaId));
            mk.addTo(store.allocMapLayers.markers);
            store.allocAreaPolys.set(String(areaId), mk);
            bounds.push([latlngs[0].lat, latlngs[0].lng]);
            continue;
          }

          if (latlngs.length === 2) {
            const line = L.polyline([[latlngs[0].lat, latlngs[0].lng], [latlngs[1].lat, latlngs[1].lng]], app.allocStyleForArea_(areaId))
              .bindTooltip(label, {
                permanent: true,
                direction: "top",
                className: "hullLabel",
                opacity: 0.95
            });

            line.on("click", () => app.toggleAllocAreaSelection_(areaId));
            line.addTo(store.allocMapLayers.hulls);
            store.allocAreaPolys.set(String(areaId), line);
            bounds.push([latlngs[0].lat, latlngs[0].lng], [latlngs[1].lat, latlngs[1].lng]);
            continue;
          }

          const hull = app.convexHull_(latlngs).map(p => [p.lat, p.lng]);
          if (hull.length < 3) continue;

          const poly = L.polygon(hull, app.allocStyleForArea_(areaId))
            .bindTooltip(label, {
              permanent: true,
              direction: "center",
              className: "hullLabel",
              opacity: 0.95
          });

          poly.on("click", () => app.toggleAllocAreaSelection_(areaId));
          poly.addTo(store.allocMapLayers.hulls);
          store.allocAreaPolys.set(String(areaId), poly);
          for (const ll of hull) bounds.push(ll);
        }

        if (bounds.length > 0) {
          try { store.allocMap.fitBounds(bounds, { padding: [16, 16] }); } catch (e) { }
        }
        setTimeout(() => { try { store.allocMap.invalidateSize(); } catch (e) { } }, 100);
      },

      toggleAllocAreaSelection_(areaId) {
        const key = String(areaId);
        if (store.selectedAreas.has(key)) store.selectedAreas.delete(key);
        else store.selectedAreas.add(key);

        app.renderAssignments();

        const layer = store.allocAreaPolys.get(key);
        if (layer && layer.setStyle) {
          try { layer.setStyle(app.allocStyleForArea_(key)); } catch (e) { }
        }
      },

      // Fieldç”¨Overview Map
      renderFieldOverviewMap_() {
        const el = document.getElementById("fieldOverviewMap");
        if (!el) return;

        const areas = (store.assigned_areas || []).slice();
        if (areas.length === 0) {
          el.innerHTML = `<div style="padding:12px" class="muted">å‰²å½“ãŒã‚ã‚Šã¾ã›ã‚“</div>`;
          return;
        }

        if (!store.fieldOverviewMap) {
          store.fieldOverviewMap = L.map("fieldOverviewMap", { zoomControl: true });
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "&copy; OpenStreetMap contributors"
          }).addTo(store.fieldOverviewMap);
          app.addLocateControlToMap_(store.fieldOverviewMap);

          store.fieldOverviewLayers.hulls = L.layerGroup().addTo(store.fieldOverviewMap);
        }

        // ã‚¯ãƒªã‚¢
        try { store.fieldOverviewLayers.hulls.clearLayers(); } catch (e) { }

        const pts = (store.points || []);
        const byArea = app.groupPointsByArea_(pts);

        const bounds = [];
        for (const areaId of areas) {
          const arr = (byArea.get(String(areaId)) || [])
            .map(p => ({ lat: Number(p.lat), lng: Number(p.lng) }))
            .filter(x => isFinite(x.lat) && isFinite(x.lng));

          if (arr.length === 0) continue;

          let layer = null;

          if (arr.length === 1) {
            layer = L.circleMarker([arr[0].lat, arr[0].lng], {
              radius: 8,
              color: "#2F7CFF",
              weight: 2,
              fillColor: "#2F7CFF",
              fillOpacity: 0.18,
            });
            bounds.push([arr[0].lat, arr[0].lng]);

          } else if (arr.length === 2) {
            layer = L.polyline([[arr[0].lat, arr[0].lng], [arr[1].lat, arr[1].lng]], {
              color: "#2F7CFF",
              weight: 3,
              opacity: 0.9,
            });
            bounds.push([arr[0].lat, arr[0].lng], [arr[1].lat, arr[1].lng]);

          } else {
            const hull = app.convexHull_(arr).map(p => [p.lat, p.lng]);
            if (hull.length < 3) continue;

            layer = L.polygon(hull, {
              color: "#2F7CFF",
              weight: 3,
              fillColor: "#2F7CFF",
              fillOpacity: 0.10,
            });
            for (const ll of hull) bounds.push(ll);
          }

          const label = app.areaLabel_(areaId);
          layer.bindTooltip(label, {
            permanent: true,
            direction: "center",
            className: "hullLabel",
            opacity: 0.95
          });

          // ã‚¿ãƒƒãƒ—ã§æŠ•ç¥¨åŒºã‚’é–‹ã
          layer.on("click", () => app.openPrecinct(String(areaId)));

          layer.addTo(store.fieldOverviewLayers.hulls);
        }

        if (bounds.length > 0) {
          try {
            store.fieldOverviewAssignedBounds = L.latLngBounds(bounds);
            store.fieldOverviewMap.fitBounds(store.fieldOverviewAssignedBounds, { padding: [16, 16] });
          } catch (e) { }
        }

        // ç¾åœ¨åœ°ï¼ˆé’ä¸¸ï¼‹ç²¾åº¦å††ï¼‰ã‚’åæ˜ 
        app.updateGeoLayers_();
        setTimeout(() => { try { store.fieldOverviewMap.invalidateSize(); } catch (e) { } }, 100);
      },

      /** -------- Leaflet map (field) -------- */
      clearMap_() {
        if (!store.map) return;
        for (const mk of store.mapMarkers) {
          try { store.map.removeLayer(mk); } catch (e) { }
        }
        store.mapMarkers = [];
      },

      renderMapForArea_(areaId) {
        const pts = store.points
          .filter(p => p.area_id === areaId)
          .slice()
          .sort((a, b) => a.order_reco - b.order_reco || a.point_id.localeCompare(b.point_id));

        if (!store.map) {
          store.map = L.map("map", { zoomControl: true });
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "&copy; OpenStreetMap contributors"
          }).addTo(store.map);
          app.addLocateControlToMap_(store.map);
        }

        if (store.mapArea !== areaId) store.mapArea = areaId;

        app.clearMap_();

        if (pts.length === 0) {
          store.map.setView([35.0, 139.0], 12);
          return;
        }

        const latlngs = [];
        for (const p of pts) {
          const lat = Number(p.lat), lng = Number(p.lng);
          if (!isFinite(lat) || !isFinite(lng)) continue;
          latlngs.push([lat, lng]);
        }

        for (const p of pts) {
          const lat = Number(p.lat), lng = Number(p.lng);
          if (!isFinite(lat) || !isFinite(lng)) continue;

          const pid = p.point_id;
          const st = store.state[pid]?.status || "todo";
          const mk = L.marker([lat, lng], { icon: markerIcon_(st) }).addTo(store.map);
          mk.__pid = pid;

          const badge = (st === "done") ? "æ¸ˆ" : "æœª";
          mk.bindPopup(`
            <div style="min-width:220px">
              <div style="font-weight:1000;font-size:16px;line-height:1.25">
                #${p.order_reco} / ${escapeHtml_(pid)}ï¼ˆ${badge}ï¼‰
              </div>
              <div style="margin-top:8px;font-size:14px;opacity:.92">${escapeHtml_((p.name || "").trim())}</div>
              <div style="margin-top:6px;font-size:13px;opacity:.75;white-space:pre-wrap">${escapeHtml_((p.address || "").trim())}</div>

              <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
                <button class="btn small" data-mk="nav"  data-pid="${escapeHtml_(pid)}">å˜ç‚¹ãƒŠãƒ“</button>
                <button class="btn small done" data-mk="done" data-pid="${escapeHtml_(pid)}">æ¸ˆ</button>
                <button class="btn small todo" data-mk="todo" data-pid="${escapeHtml_(pid)}">æœª</button>
                <button class="btn small memo" data-mk="memo" data-pid="${escapeHtml_(pid)}">ãƒ¡ãƒ¢</button>
              </div>
            </div>
          `);

          mk.on("popupopen", (ev) => {
            const root = ev.popup.getElement();
            if (!root) return;
            const pid2 = root.querySelector("[data-pid]")?.getAttribute("data-pid");
            if (!pid2) return;

            root.querySelector('[data-mk="nav"]')?.addEventListener("click", () => app.startSingleNav(pid2));
            root.querySelector('[data-mk="done"]')?.addEventListener("click", (e) => app.handlePointAction("done", pid2, e.currentTarget));
            root.querySelector('[data-mk="todo"]')?.addEventListener("click", (e) => app.handlePointAction("todo", pid2, e.currentTarget));
            root.querySelector('[data-mk="memo"]')?.addEventListener("click", (e) => app.handlePointAction("memo", pid2, e.currentTarget));
          });

          store.mapMarkers.push(mk);
        }

        if (latlngs.length >= 1) {
          try { store.areaPointsBounds = L.latLngBounds(latlngs); } catch (e) { store.areaPointsBounds = null; }
        }

        if (latlngs.length >= 2) store.map.fitBounds(latlngs, { padding: [20, 20] });
        else {
          // 1ç‚¹ã ã‘ã®æ™‚ã‚‚ã‚ºãƒ¼ãƒ ã—éããªã„ï¼ˆè¦‹å¤±ã„é˜²æ­¢ï¼‰
          const z = store.map.getZoom ? store.map.getZoom() : 15;
          store.map.setView(latlngs[0], Math.min(15, z || 15));
        }

        // ç¾åœ¨åœ°ï¼ˆé’ä¸¸ï¼‹ç²¾åº¦å††ï¼‰ã‚’åæ˜ 
        app.updateGeoLayers_();
      },

      updateMapMarker_(point_id) {
        for (const mk of store.mapMarkers) {
          if (mk.__pid === point_id) {
            const st = store.state[point_id]?.status || "todo";
            mk.setIcon(markerIcon_(st));
            break;
          }
        }
      },

      /** -------- Summary -------- */
      async loadSummary() {
        ui.toast("é›†è¨ˆå–å¾—ä¸­â€¦");
        const resp = await postAction({ action: "summary_get", actor_user_id: store.user_id });
        if (!resp.ok) {
          const el = document.getElementById("sumList");
          el.innerHTML = `
            <div class="item">
              <div style="font-weight:1000;font-size:16px">é›†è¨ˆã¯æœªå¯¾å¿œ</div>
              <div class="tiny">GASå´ã« action:"summary_get" ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚error=${escapeHtml_(resp.error || "")}</div>
            </div>`;
          return;
        }

        const points = resp.points || [];
        let state = resp.state || {};
        if (!state || typeof state !== "object") state = {};

        const pickMemo = (obj) => String(obj?.memo ?? obj?.note ?? obj?.comment ?? obj?.message ?? "");
        const pickStatus = (obj) => String(obj?.status ?? obj?.st ?? "todo");

        for (const p of points) {
          const pid = String(p.point_id || "");
          if (!pid) continue;
          if (!state[pid] || typeof state[pid] !== "object") state[pid] = {};
          if (!state[pid].status) state[pid].status = pickStatus(p);
          if (!state[pid].memo) state[pid].memo = pickMemo(p);
        }
        for (const pid of Object.keys(state)) {
          state[pid].status = pickStatus(state[pid]);
          state[pid].memo = pickMemo(state[pid]);
        }

        store.summary = { ok: true, points, state };

        // --- è¿½åŠ ï¼šplanner/allocator ã®ã¨ãã ã‘ã€æŠ•ç¥¨åŒºâ†’æ‹…å½“è€…(display_name) ã‚’å–å¾—ã—ã¦ãƒ¦ãƒ¼ã‚¶çµã‚Šè¾¼ã¿ã‚’æœ‰åŠ¹åŒ–
        store.summary_area_to_user = {};
        const canAlloc = (store.role === "allocator" || store.role === "planner");
        const userWrap = document.getElementById("sumUserWrap");
        const userSel  = document.getElementById("sumUser");
        if (canAlloc && userWrap && userSel) {
          try {
            const assnResp = await postAction({ action: "alloc_list_assignments", actor_user_id: store.user_id });
            if (assnResp.ok) {
              const assn = assnResp.assignments || [];
              for (const a of assn) {
                const areaId = String(a.area_id || "");
                const dn = String(a.assignee_display_name || "").trim();
                if (areaId) store.summary_area_to_user[areaId] = dn; // dnãŒç©ºãªã‚‰æœªå‰²å½“
              }

              // ãƒ¦ãƒ¼ã‚¶å€™è£œï¼ˆæœªå‰²å½“ã¯é™¤å¤–ã€‚å¿…è¦ãªã‚‰å…¥ã‚Œã¦OKï¼‰
              const users = Array.from(new Set(
                Object.values(store.summary_area_to_user).map(s => String(s || "").trim()).filter(Boolean)
              )).sort((a,b)=>a.localeCompare(b,'ja'));

              const curU = userSel.value || "";
              userSel.innerHTML = `<option value="">ï¼ˆå…¨ãƒ¦ãƒ¼ã‚¶ï¼‰</option>` + users.map(u =>
                `<option value="${escapeHtml_(u)}">${escapeHtml_(u)}</option>`
              ).join("");
              userSel.value = curU;
              userWrap.style.display = "block";
            } else {
              userWrap.style.display = "none";
            }
          } catch (e) {
            userWrap.style.display = "none";
          }
        } else {
          if (userWrap) userWrap.style.display = "none";
        }


        const sel = document.getElementById("sumArea");
        const areas = Array.from(new Set(points.map(p => String(p.area_id || "")))).filter(Boolean).sort();
        const cur = sel.value || "";
        sel.innerHTML = `<option value="">ï¼ˆå…¨æŠ•ç¥¨åŒºï¼‰</option>` + areas.map(a => {
          const num = a.replace(/^P0*/, "");
          return `<option value="${escapeHtml_(a)}">æŠ•ç¥¨åŒºï¼š${escapeHtml_(num)}</option>`;
        }).join("");
        sel.value = cur;

        app.renderSummary();
        ui.toast("é›†è¨ˆã‚’æ›´æ–°ã—ã¾ã—ãŸ");
      },

      renderSummary() {
        if (!store.summary.ok) return;

        const area = (document.getElementById("sumArea")?.value || "").trim();
        const wantTodo = document.getElementById("sumTodo")?.checked ?? true;
        const wantDone = document.getElementById("sumDone")?.checked ?? true;
        const wantMemo = document.getElementById("sumMemo")?.checked ?? false;
        const wantUser = (document.getElementById("sumUser")?.value || "").trim();

        function matchStatus(st) {
          if (wantTodo && wantDone) return true;
          if (!wantTodo && !wantDone) return true;
          if (wantTodo && st !== "done") return true;
          if (wantDone && st === "done") return true;
          return false;
        }

        const pts = (store.summary.points || [])
          .map(p => {
            const pid = String(p.point_id || "");
            const st = String(store.summary.state?.[pid]?.status || "todo");
            const memo = String(store.summary.state?.[pid]?.memo || "").trim();
            const areaId = String(p.area_id || "");
            const assignee = String(store.summary_area_to_user?.[areaId] || "").trim();
            return { ...p, status: st, memo, assignee_display_name: assignee };
          })
          .filter(p => !area || String(p.area_id) === area)
          .filter(p => matchStatus(String(p.status || "todo")))
          .filter(p => !wantMemo || !!String(p.memo || "").trim())
          .filter(p => !wantUser || String(p.assignee_display_name || "") === wantUser)
          .slice()
          .sort((a, b) => String(a.area_id).localeCompare(String(b.area_id)) || Number(a.order_reco || 0) - Number(b.order_reco || 0) || String(a.point_id).localeCompare(String(b.point_id)));

        const all = (store.summary.points || []).map(p => String(store.summary.state?.[String(p.point_id || "")]?.status || "todo"));
        const kTotal = all.length;
        const kDone = all.filter(s => s === "done").length;
        const kTodo = kTotal - kDone;
        document.getElementById("sumKpiTotal").textContent = `ç·æ•°ï¼š${kTotal}`;
        document.getElementById("sumKpiTodo").textContent = `æœªï¼š${kTodo}`;
        document.getElementById("sumKpiDone").textContent = `æ¸ˆï¼š${kDone}`;

        const el = document.getElementById("sumList");
        el.innerHTML = "";

        if (pts.length === 0) {
          el.innerHTML = `<div class="item"><div style="font-weight:1000;font-size:16px">è©²å½“ãªã—</div><div class="tiny">çµã‚Šè¾¼ã¿æ¡ä»¶ã‚’å¤‰ãˆã¦ãã ã•ã„ã€‚</div></div>`;
          return;
        }

        let curArea = "";
        for (const p of pts) {
          const a = String(p.area_id || "");
          if (a !== curArea) {
            curArea = a;
            const num = a.replace(/^P0*/, "");
            const header = document.createElement("div");
            header.className = "item";
            header.innerHTML = `<div style="font-weight:1000;font-size:16px">æŠ•ç¥¨åŒºï¼š${escapeHtml_(num)}</div>`;
            el.appendChild(header);
          }

          const item = document.createElement("div");
          item.className = "item";
          item.innerHTML = `
            <div class="pointMeta">
              #${Number(p.order_reco || 0)} / ${escapeHtml_(p.point_id || "")} ${p.status === "done" ? `<span class="badge bDone">æ¸ˆ</span>` : `<span class="badge bTodo">æœª</span>`}
            </div>
            ${p.assignee_display_name ? `<div class="tiny muted">æ‹…å½“ï¼š${escapeHtml_(p.assignee_display_name)}</div>` : ``}
            <div class="pointName">${escapeHtml_((p.name || "").trim())}</div>
            <div class="pointAddr">${escapeHtml_((p.address || "").trim())}</div>
            ${p.memo ? `<div class="pointMemo">ğŸ“ ${escapeHtml_(p.memo)}</div>` : ``}
          `;
          el.appendChild(item);
        }
      },

      /** -------- Allocator -------- */
      async loadAllocatorData() {
        const usersResp = await postAction({ action: "alloc_list_users", actor_user_id: store.user_id });
        const assnResp = await postAction({ action: "alloc_list_assignments", actor_user_id: store.user_id });
        const pendResp = await postAction({ action: "pending_list", actor_user_id: store.user_id });
        const ptsResp = await postAction({ action: "alloc_points_all", actor_user_id: store.user_id });

        if (!usersResp.ok || !assnResp.ok || !pendResp.ok) {
          ui.toast("â€»GASã« alloc_list_users / alloc_list_assignments ãŒå¿…è¦ã§ã™");
          store.allUsers = [];
          store.assignments = [];
          store.allocPointsAll = [];
          app.renderUserCandidates();
          app.renderAssignments();
          return;
        }

        store.allUsers = usersResp.users || [];
        store.assignments = assnResp.assignments || [];
        store.pendingUsers = pendResp.pending || [];
        store.selectedAreas = new Set();
        app.renderUserCandidates();
        app.renderAssignments();
        app.renderPendingList_();
        app.updatePendingBadge_();

        if (!ptsResp.ok) {
          ui.toast("â€»GASã« alloc_points_all ã‚’è¿½åŠ ã—ã¦ãã ã•ã„");
          store.allocPointsAll = [];
          return;
        }

        store.allocPointsAll = ptsResp.points || [];

        // âœ… ã“ã“ã§å…¨ä½“ãƒãƒƒãƒ—ã‚’æç”»ï¼ˆâ†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã«å®Ÿè¡Œæ–‡ã‚’ç½®ã‹ãªã„ï¼‰
        app.renderAllocOverviewMap_();
      },

      renderUserCandidates() {
        const q = (document.getElementById("inUserSearch")?.value || "").trim().toLowerCase();
        const el = document.getElementById("userCandidates");
        if (!el) return;
        el.innerHTML = "";

        const list = store.allUsers
          .filter(u => (u.status || "active") === "active")
          .filter(u => (u.role === "field" || u.role === "allocator" || u.role === "planner"))
          .filter(u => !q || (u.display_name || "").toLowerCase().includes(q))
          .slice(0, 10);

        if (list.length === 0) {
          el.innerHTML = `<div class="item"><div style="font-weight:1000;font-size:16px">å€™è£œãªã—</div><div class="tiny">users ã‚’å–å¾—ã§ãã¦ã„ãªã„å ´åˆã¯GASå´ã® action ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</div></div>`;
          return;
        }

        for (const u of list) {
          const item = document.createElement("div");
          item.className = "item";
          const selected = store.selectedAssignee && store.selectedAssignee.user_id === u.user_id;
          item.innerHTML = `
            <div class="itemTop">
              <div>
                <div style="font-weight:1000;font-size:16px">${selected ? "âœ… " : ""}${escapeHtml_(u.display_name)}</div>
                <div class="tiny">role: ${escapeHtml_(u.role)} / user_id: <span class="mono">${escapeHtml_(u.user_id)}</span></div>
              </div>
              <button class="btn small primary">é¸æŠ</button>
            </div>
          `;
          item.querySelector("button").onclick = () => {
            store.selectedAssignee = { user_id: u.user_id, display_name: u.display_name };
            ui.toast("æ‹…å½“è€…ã‚’é¸æŠã—ã¾ã—ãŸ");
            app.renderUserCandidates();
          };
          el.appendChild(item);
        }
      },

      renderAssignments() {
        const el = document.getElementById("assignList");
        if (!el) return;
        el.innerHTML = "";

        const list = (store.assignments || []).slice().sort((a, b) => String(a.area_id).localeCompare(String(b.area_id)));
        for (const a of list) {
          const area = String(a.area_id || "");
          const checked = store.selectedAreas.has(area);
          const num = area.replace(/^P0*/, "");
          const item = document.createElement("div");
          item.className = "item";
          item.innerHTML = `
            <div class="itemTop">
              <div>
                <div style="font-weight:1000;font-size:16px;line-height:1.2">
                  <input type="checkbox" ${checked ? "checked" : ""} />
                  <span style="margin-left:8px">æŠ•ç¥¨åŒºï¼š${escapeHtml_(num)}</span>
                  <span class="badge" style="margin-left:8px">v${Number(a.version || 1)}</span>
                  <span class="badge" style="margin-left:6px">${escapeHtml_(a.status || "")}</span>
                </div>
                <div class="tiny">æ‹…å½“ï¼š${escapeHtml_(a.assignee_display_name || "ï¼ˆæœªå‰²å½“ï¼‰")}</div>
                ${(a.note ? `<div class="tiny muted" style="margin-top:6px;">å¼•ç¶™ããƒ¡ãƒ¢ï¼š${escapeHtml_(a.note)}</div>` : "")}
              </div>
            </div>
          `;
          item.querySelector("input").onchange = (e) => {
            if (e.target.checked) store.selectedAreas.add(area);
            else store.selectedAreas.delete(area);

            const layer = store.allocAreaPolys?.get?.(String(area));
            if (layer && layer.setStyle) {
              try { layer.setStyle(app.allocStyleForArea_(area)); } catch (err) { }
            }
          };
          el.appendChild(item);
        }
      
      },

      updatePendingBadge_(){
        const badge = document.getElementById("pendingBadge");
        if (!badge) return;
        const n = (store.pendingUsers || []).length;
        if (n > 0) {
          badge.style.display = "inline-block";
          badge.textContent = "æ‰¿èªå¾…ã¡ " + String(n);
        } else {
          badge.style.display = "none";
        }
      },

      renderPendingList_(){
        const el = document.getElementById("pendingList");
        if (!el) return;
        el.innerHTML = "";

        const list = (store.pendingUsers || []).slice()
          .sort((a,b)=> String(a.created_at||"").localeCompare(String(b.created_at||"")));

        if (list.length === 0) {
          el.innerHTML = `<div class="item"><div class="itemTitle">æ‰¿èªå¾…ã¡ãªã—</div><div class="itemSub muted">æ–°è¦ç™»éŒ²ãŒã‚ã‚‹ã¨ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div></div>`;
          return;
        }

        for (const u of list) {
          const item = document.createElement("div");
          item.className = "item";
          item.innerHTML = `
            <div class="itemTop">
              <div>
                <div class="itemTitle">${escapeHtml_(u.display_name || (u.nickname||""))}</div>
                <div class="itemSub">nickname: ${escapeHtml_(u.nickname||"")} / id: ${escapeHtml_(u.id_name||"")}</div>
                <div class="tiny">user_id: <span class="mono">${escapeHtml_(u.user_id||"")}</span> / created: ${escapeHtml_(u.created_at||"-")}</div>
              </div>
            </div>
            <div class="actions">
              <button class="btn small ok" data-act="approve">æ‰¿èª</button>
              <button class="btn small danger" data-act="reject">å´ä¸‹</button>
            </div>
          `;
          item.querySelector('button[data-act="approve"]').onclick = async () => {
            if (!confirm(`æ‰¿èªã—ã¾ã™ã‹ï¼Ÿ
${u.display_name}`)) return;
            const resp = await postAction({ action:"pending_approve", actor_user_id: store.user_id, user_id: u.user_id });
            if (!resp.ok) { ui.toast("æ‰¿èªå¤±æ•—ï¼š" + (resp.error||"")); return; }
            ui.toast("æ‰¿èªã—ã¾ã—ãŸ");
            await app.loadAllocatorData();
          };
          item.querySelector('button[data-act="reject"]').onclick = async () => {
            if (!confirm(`å´ä¸‹ã—ã¾ã™ã‹ï¼Ÿ
${u.display_name}`)) return;
            const resp = await postAction({ action:"pending_reject", actor_user_id: store.user_id, user_id: u.user_id });
            if (!resp.ok) { ui.toast("å´ä¸‹å¤±æ•—ï¼š" + (resp.error||"")); return; }
            ui.toast("å´ä¸‹ã—ã¾ã—ãŸ");
            await app.loadAllocatorData();
          };
          el.appendChild(item);
        }
      },

      async bulkAssign() {
        if (!store.selectedAssignee) { ui.toast("æ‹…å½“è€…ã‚’é¸æŠã—ã¦ãã ã•ã„"); return; }
        if (store.selectedAreas.size === 0) { ui.toast("æŠ•ç¥¨åŒºã‚’é¸æŠã—ã¦ãã ã•ã„"); return; }
        const note = (document.getElementById("inAssignNote").value || "").trim();

        const ops = [];
        for (const area of store.selectedAreas) {
          const a = store.assignments.find(x => String(x.area_id) === String(area));
          if (!a) continue;
          ops.push({
            area_id: area,
            action: "assign",
            assignee_user_id: store.selectedAssignee.user_id,
            expected_version: Number(a.version),
            note
          });
        }

        const resp = await postAction({ action: "alloc_update", actor_user_id: store.user_id, ops });
        if (!resp.ok) { ui.toast("å‰²å½“å¤±æ•—ï¼š" + (resp.error || "")); return; }

        let conflict = 0, ok = 0;
        for (const r of (resp.results || [])) {
          if (r.ok) ok++;
          else if (r.error === "CONFLICT") conflict++;
        }
        ui.toast(`å‰²å½“ï¼šæˆåŠŸ${ok} / ç«¶åˆ${conflict}`);
        await app.loadAllocatorData();
      },

      async bulkUnassign() {
        if (store.selectedAreas.size === 0) { ui.toast("æŠ•ç¥¨åŒºã‚’é¸æŠã—ã¦ãã ã•ã„"); return; }
        const note = (document.getElementById("inAssignNote").value || "").trim();

        const ops = [];
        for (const area of store.selectedAreas) {
          const a = store.assignments.find(x => String(x.area_id) === String(area));
          if (!a) continue;
          ops.push({
            area_id: area,
            action: "unassign",
            expected_version: Number(a.version),
            note
          });
        }

        const resp = await postAction({ action: "alloc_update", actor_user_id: store.user_id, ops });
        if (!resp.ok) { ui.toast("è§£é™¤å¤±æ•—ï¼š" + (resp.error || "")); return; }

        let conflict = 0, ok = 0;
        for (const r of (resp.results || [])) {
          if (r.ok) ok++;
          else if (r.error === "CONFLICT") conflict++;
        }
        ui.toast(`è§£é™¤ï¼šæˆåŠŸ${ok} / ç«¶åˆ${conflict}`);
        await app.loadAllocatorData();
      },
      async allowlistDisable() {
        const allow_id = (document.getElementById("alDisableId").value || "").trim();
        if (!allow_id) { ui.toast("allow_id ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
        const resp = await postAction({ action: "allowlist_disable", actor_user_id: store.user_id, allow_id });
        if (!resp.ok) { ui.toast("ç„¡åŠ¹åŒ–å¤±æ•—ï¼š" + (resp.error || "")); return; }
        ui.toast("ç„¡åŠ¹åŒ–ã—ã¾ã—ãŸ");
        document.getElementById("alDisableId").value = "";
      }
    };

    window.app = app;
    app.init();
  </script>

</body>


</html>
